# 会话历史记录

## 会话主要目的
修改 NestJS 项目中的时间格式，将 created_at 和 updated_at 字段从 ISO 8601 格式（如 2025-09-09T09:45:59.834Z）改为 YYYY-MM-DD HH:mm:ss.ms 格式。

## 完成的主要任务
1. 创建了时间格式化工具函数 `date_formatter.ts`
2. 修改了响应拦截器 `response.interceptor.ts` 以自动格式化时间字段
3. 更新了 DTO 文件中的时间格式示例

## 关键决策和解决方案
- 在 `common/utils` 目录下创建了 `date_formatter.ts` 工具文件
- 使用递归函数 `format_object_dates` 来格式化嵌套对象中的时间字段
- 在响应拦截器中集成时间格式化功能，确保所有 API 响应都使用统一的时间格式
- 更新了所有 DTO 类中的时间字段示例，从 ISO 格式改为 YYYY-MM-DD HH:mm:ss.ms 格式

## 使用的技术栈
- TypeScript
- NestJS
- 自定义工具函数
- 响应拦截器

## 修改的文件
1. `back1/src/common/utils/date_formatter.ts` - 新建时间格式化工具函数
2. `back1/src/common/interceptors/response.interceptor.ts` - 修改响应拦截器集成时间格式化
3. `back1/src/common/dto/paginated_response.dto.ts` - 更新 DTO 中的时间格式示例

## 测试结果
✅ 时间格式化功能已成功实现并测试通过
- 原始格式：`2025-09-09T09:45:59.834Z`
- 新格式：`2025-09-09 17:45:59.834`
- API 响应中的 `created_at` 和 `updated_at` 字段已自动格式化为 `YYYY-MM-DD HH:mm:ss.ms` 格式

## 说明
文件中的内容是累积增加的，每次会话都会追加新的记录。

---

## 会话主要目的
清理 NestJS 认证模块中的 LocalStrategy 相关代码，简化认证系统架构。

## 完成的主要任务
1. 从 `auth.module.ts` 中移除 LocalStrategy 的导入和注册
2. 从 `auth.controller.ts` 中移除 LocalAuthGuard 的导入
3. 删除 `local.strategy.ts` 和 `local_auth.guard.ts` 文件

## 关键决策和解决方案
- 移除不再使用的 passport-local 策略相关代码
- 保持 JWT 认证策略作为主要的认证方式
- 简化认证模块的依赖关系

## 使用的技术栈
- TypeScript
- NestJS
- Passport JWT

## 修改的文件
1. `back1/src/modules/auth/auth.module.ts` - 移除 LocalStrategy 导入和注册
2. `back1/src/modules/auth/auth.controller.ts` - 移除 LocalAuthGuard 导入
3. `back1/src/modules/auth/strategies/local.strategy.ts` - 删除文件
4. `back1/src/modules/auth/guards/local_auth.guard.ts` - 删除文件

## 说明
文件中的内容是累积增加的，每次会话都会追加新的记录。

---

## 会话主要目的
简化代码库，移除未使用的 RolesGuard 和 Roles 装饰器功能。

## 完成的主要任务
1. 检查 RolesGuard 和 Roles 装饰器的使用情况
2. 删除未使用的 `roles.guard.ts` 文件
3. 删除未使用的 `roles.decorator.ts` 文件

## 关键决策和解决方案
- 通过代码搜索确认 RolesGuard 和 Roles 装饰器在项目中未被使用
- 安全删除未使用的权限控制相关文件
- 保持代码库的简洁性，移除冗余代码

## 使用的技术栈
- TypeScript
- NestJS
- 代码清理和重构

## 修改的文件
1. `back1/src/common/guards/roles.guard.ts` - 删除文件
2. `back1/src/common/decorators/roles.decorator.ts` - 删除文件

## 说明
文件中的内容是累积增加的，每次会话都会追加新的记录。

---

## 会话主要目的
修复 back2 项目中 dayjs 导入问题，解决 `payload2---dayjs: undefined` 错误。

## 完成的主要任务
1. 检查 dayjs 包的安装情况
2. 修复 dayjs 的导入方式
3. 更新 TypeScript 配置以支持 ES 模块导入
4. 添加调试日志验证修复效果

## 关键决策和解决方案
- 发现 dayjs 包已正确安装在 package.json 中
- 将 ES6 导入语法 `import dayjs from 'dayjs'` 改为 CommonJS 语法 `const dayjs = require('dayjs')`
- 在 tsconfig.json 中添加 `esModuleInterop: true` 配置
- 添加详细的调试日志来验证 dayjs 功能

## 使用的技术栈
- TypeScript
- NestJS
- dayjs 日期处理库
- CommonJS 模块系统

## 修改的文件
1. `back2/src/App_Controller.ts` - 修复 dayjs 导入方式，添加调试日志
2. `back2/tsconfig.json` - 添加 esModuleInterop 配置

## 问题分析
- 原始问题：`payload2---dayjs: undefined` 表示 dayjs 导入失败
- 根本原因：ES6 模块导入语法在 CommonJS 环境中的兼容性问题
- 解决方案：使用 CommonJS 的 require 语法导入 dayjs

## 说明
文件中的内容是累积增加的，每次会话都会追加新的记录。

---

## 会话主要目的
修复 back2 项目中 VO_Dynamic.ts 文件的装饰器错误，解决"修饰器在此处无效"的问题。

## 完成的主要任务
1. 分析动态类中装饰器无效的问题
2. 移除动态创建类中的 @ApiProperty 装饰器
3. 保持动态创建类的功能，让 Swagger 从父类继承装饰器信息

## 关键决策和解决方案
- 发现问题：在动态创建的类中使用 @ApiProperty 装饰器会导致"修饰器在此处无效"错误
- 根本原因：装饰器需要在类定义时就能被解析，而不是在运行时动态创建
- 解决方案：移除动态类中的装饰器，让 Swagger 从父类 Base_Response_Dto 继承装饰器信息

## 使用的技术栈
- TypeScript
- NestJS
- Swagger 装饰器
- 动态类创建

## 修改的文件
1. `back2/src/VO_Dynamic.ts` - 移除动态类中的 @ApiProperty 装饰器

## 问题分析
- 原始问题：动态创建的类中使用 @ApiProperty 装饰器报错
- 根本原因：装饰器无法在运行时动态创建的类中正确工作
- 解决方案：移除装饰器，依赖父类的装饰器信息

## 说明
文件中的内容是累积增加的，每次会话都会追加新的记录。

---

## 会话主要目的
完善 back2 项目中 VO_Dynamic.ts 的 Swagger 文档生成，解决 result 对象显示为空的问题。

## 完成的主要任务
1. 修复 App_test2.ts 中返回数据的 key 名称从 one2 改为 one22
2. 改进 VO_Dynamic.ts 中的动态类创建方式，使用静态类定义替代动态类
3. 恢复装饰器功能，确保 Swagger 能正确识别嵌套数据结构

## 关键决策和解决方案
- 发现问题：移除装饰器后 Swagger 无法识别 result 对象的具体结构，显示为空对象
- 解决方案：将动态类创建改为静态类定义，恢复 @ApiProperty 装饰器功能
- 确保 API 文档能正确显示 one22 键及其对应的数据结构

## 使用的技术栈
- TypeScript
- NestJS
- Swagger 装饰器
- 静态类定义

## 修改的文件
1. `back2/src/App_test2.ts` - 修复返回数据中的 key 名称
2. `back2/src/VO_Dynamic.ts` - 改进动态类创建方式，恢复装饰器功能

## 问题分析
- 原始问题：API 文档中 result 对象显示为空 {}
- 根本原因：移除装饰器后 Swagger 无法识别嵌套数据结构
- 解决方案：使用静态类定义替代动态类，恢复装饰器功能

## 说明
文件中的内容是累积增加的，每次会话都会追加新的记录。

---

## 会话主要目的
改造 back3 项目中的 VO_Dynamic 函数，支持多字段数组格式，从单字段格式 `VO_Dynamic(Dto_one1, 'one111')` 改为多字段格式 `VO_Dynamic([{key:'one111',type:Dto_one1}, {key:'aaa',type:type_aaa}])`。

## 完成的主要任务
1. 修改 `VO_Dynamic.ts` 中的 `VO_Dynamic` 函数，支持多字段数组格式
2. 更新 `App_test1.ts` 中的 `@ApiOkResponse` 装饰器，使用新的多字段格式
3. 保持向后兼容性，支持原有的单字段格式

## 关键决策和解决方案
- 添加 `FieldDefinition` 接口定义字段结构
- 修改 `VO_Dynamic` 函数参数，支持数组和单字段两种格式
- 使用类型断言解决 TypeScript 类型检查问题
- 动态创建包装类，为每个字段添加 `@ApiProperty` 装饰器
- 保持原有单字段格式的向后兼容性

## 使用的技术栈
- TypeScript
- NestJS
- Swagger 装饰器
- 动态类创建
- 类型断言

## 修改的文件
1. `back3/src/test/test4/VO_Dynamic.ts` - 改造 VO_Dynamic 函数支持多字段数组格式
2. `back3/src/test/test4/App_test1.ts` - 更新 ApiOkResponse 使用新的多字段格式

## 技术实现细节
- 新增 `FieldDefinition<T>` 接口定义字段结构
- 修改函数签名：`VO_Dynamic<T>(fieldDefinitions: FieldDefinition[] | (new () => T), keyName?: string)`
- 使用 `Array.isArray()` 判断输入格式
- 动态创建包装类，为每个字段添加 `@ApiProperty` 装饰器
- 保持原有单字段格式的完全兼容

## 说明
文件中的内容是累积增加的，每次会话都会追加新的记录。

---

## 会话主要目的
使用装饰器解决 back3 项目中 dto1 和 dto2/dto1 类名冲突问题，实现优雅的命名空间管理。

## 完成的主要任务
1. 创建了 `@Namespace` 装饰器用于标识类的命名空间
2. 为两个 dto1 类分别添加了不同的命名空间装饰器
3. 创建了命名空间工具类 `NamespaceUtils` 提供类型安全的类引用
4. 更新了导入语句使用类型别名区分不同命名空间的类
5. 创建了使用示例文件展示装饰器解决方案

## 关键决策和解决方案
- 使用 `@Namespace` 装饰器为每个类添加命名空间标识
- 通过 `reflect-metadata` 存储命名空间信息到类的元数据中
- 创建 `NamespaceUtils` 工具类提供类型安全的类引用检查
- 使用 TypeScript 类型别名 (`as`) 在导入时区分同名类
- 保持原有类名不变，通过装饰器和类型别名解决冲突

## 使用的技术栈
- TypeScript
- NestJS
- 装饰器 (Decorators)
- reflect-metadata
- 元数据编程

## 修改的文件
1. `back3/src/common/decorators/namespace.decorator.ts` - 新建命名空间装饰器
2. `back3/src/common/utils/namespace_utils.ts` - 新建命名空间工具类
3. `back3/src/test/test4/dto1/dto1.ts` - 添加 @Namespace('dto1_module') 装饰器
4. `back3/src/test/test4/dto2/dto1.ts` - 添加 @Namespace('dto2_module') 装饰器
5. `back3/src/test/test4/test4_App_test1.ts` - 使用类型别名 Dto1FromModule1
6. `back3/src/test/test4/test4_App_test2.ts` - 使用类型别名 Dto1FromModule2
7. `back3/src/test/test4/namespace_example.ts` - 新建使用示例文件

## 技术实现细节
- `@Namespace` 装饰器将命名空间信息存储到类的元数据中
- 为装饰的类添加静态方法 `getNamespace()` 和 `getFullName()`
- `NamespaceUtils` 提供类型安全的类引用检查和创建
- 使用 TypeScript 类型别名避免导入时的命名冲突
- 支持运行时命名空间验证和错误处理

## 优势
- 保持原有类名不变，向后兼容
- 提供类型安全的命名空间管理
- 支持运行时命名空间验证
- 代码清晰，易于维护
- 可扩展性强，支持更多命名空间

## 说明
文件中的内容是累积增加的，每次会话都会追加新的记录。

---

## 会话主要目的
修复装饰器实现中的 TypeScript 编译错误，确保命名空间装饰器正常工作。

## 完成的主要任务
1. 修复了 `@Namespace` 装饰器中的 TypeScript 类型错误
2. 优化了装饰器接口定义，使用类型断言解决动态方法添加问题
3. 移除了不必要的接口实现，简化了类定义
4. 更新了示例文件，使用正确的类型断言访问装饰器添加的方法
5. 验证了项目编译成功，所有错误已解决

## 关键决策和解决方案
- 使用类型断言 `(constructor as any)` 解决动态添加静态方法的类型问题
- 简化接口定义，移除不必要的接口实现
- 使用可选方法 `getNamespace?()` 和 `getFullName?()` 避免类型冲突
- 在示例中使用 `(class as any).method?.()` 安全访问装饰器添加的方法

## 使用的技术栈
- TypeScript
- NestJS
- 装饰器 (Decorators)
- reflect-metadata
- 类型断言 (Type Assertion)

## 修改的文件
1. `back3/src/common/decorators/namespace.decorator.ts` - 修复类型错误，优化接口定义
2. `back3/src/test/test4/dto1/dto1.ts` - 移除接口实现，简化类定义
3. `back3/src/test/test4/dto2/dto1.ts` - 移除接口实现，简化类定义
4. `back3/src/test/test4/namespace_example.ts` - 更新示例，使用类型断言

## 技术实现细节
- 使用 `(constructor as any)` 类型断言解决动态方法添加的类型问题
- 装饰器返回类型为 `T & NamespaceDecorated` 确保类型安全
- 接口中的方法设为可选，避免实现时的类型冲突
- 在运行时通过类型断言安全访问装饰器添加的静态方法

## 验证结果
- 所有 TypeScript 编译错误已解决
- 项目编译成功 (`pnpm run build` 通过)
- 装饰器功能正常工作
- 类型安全得到保证

## 说明
文件中的内容是累积增加的，每次会话都会追加新的记录。

---

## 会话主要目的
彻底解决Swagger文档中DTO类名覆盖的问题，通过重命名类来避免冲突。

## 完成的主要任务
1. 将 `dto1/dto1.ts` 中的类重命名为 `dto1_test1`
2. 将 `dto2/dto1.ts` 中的类重命名为 `dto1_test2`
3. 更新所有引用这些DTO的文件中的导入和使用
4. 验证类名不再冲突，Swagger文档可以正确区分
5. 测试验证修复效果

## 关键决策和解决方案
- 采用类名重命名策略，而不是仅依赖装饰器
- 保持装饰器功能用于命名空间管理
- 使用描述性的类名 `dto1_test1` 和 `dto1_test2` 来区分
- 更新所有相关文件的导入和类型引用

## 使用的技术栈
- TypeScript
- NestJS
- Swagger/OpenAPI
- 装饰器 (Decorators)
- 类重命名策略

## 修改的文件
1. `back3/src/test/test4/dto1/dto1.ts` - 类名从 `dto1` 改为 `dto1_test1`
2. `back3/src/test/test4/dto2/dto1.ts` - 类名从 `dto1` 改为 `dto1_test2`
3. `back3/src/test/test4/test4_App_test1.ts` - 更新导入和类型引用
4. `back3/src/test/test4/test4_App_test2.ts` - 更新导入和类型引用
5. `back3/src/test/test4/namespace_example.ts` - 更新导入引用

## 技术实现细节
- 使用不同的类名避免Swagger文档中的覆盖问题
- 保持装饰器功能用于运行时命名空间管理
- 更新所有类型引用确保类型安全
- 验证类名确实不同，避免任何冲突

## 验证结果
- 两个DTO类现在有不同的类名：`dto1_test1` 和 `dto1_test2`
- 类名比较测试通过：`false` (不相同)
- 实例创建和属性访问正常
- 项目编译成功
- Swagger文档不再有覆盖问题

## 说明
文件中的内容是累积增加的，每次会话都会追加新的记录。

---

## 会话主要目的
按照用户要求，保持两个DTO文件中的类名都是 `dto1`，但解决Swagger文档中的覆盖问题。

## 完成的主要任务
1. 恢复两个DTO文件中的类名为 `dto1`
2. 更新所有引用文件中的导入和类型引用
3. 使用 `@ApiProperty` 的 `description` 和 `title` 属性来区分不同的DTO
4. 添加 `@ApiExtraModels` 装饰器来明确注册模型
5. 保持类名相同但通过描述信息区分

## 关键决策和解决方案
- 保持类名都是 `dto1`，满足用户要求
- 使用 `@ApiProperty` 的 `description` 属性添加模块标识
- 使用 `@ApiProperty` 的 `title` 属性为每个DTO指定不同的标题
- 添加 `@ApiExtraModels` 装饰器确保模型正确注册
- 通过描述信息让用户能够区分不同的DTO

## 使用的技术栈
- TypeScript
- NestJS
- Swagger/OpenAPI
- 装饰器 (Decorators)
- ApiProperty 配置

## 修改的文件
1. `back3/src/test/test4/dto1/dto1.ts` - 恢复类名为 `dto1`，添加描述信息
2. `back3/src/test/test4/dto2/dto1.ts` - 恢复类名为 `dto1`，添加描述信息
3. `back3/src/test/test4/test4_App_test1.ts` - 更新导入和添加 `@ApiExtraModels`
4. `back3/src/test/test4/test4_App_test2.ts` - 更新导入和添加 `@ApiExtraModels`
5. `back3/src/test/test4/namespace_example.ts` - 更新导入引用

## 技术实现细节
- 两个DTO类都保持 `dto1` 类名
- 通过 `@ApiProperty` 的 `description` 属性区分：`name_aaa1 (from dto1_module)` vs `name_aaa2 (from dto2_module)`
- 通过 `@ApiProperty` 的 `title` 属性指定不同标题：`dto1_test1_module` vs `dto1_test2_module`
- 使用 `@ApiExtraModels` 装饰器确保模型正确注册到Swagger
- 保持命名空间装饰器功能

## 验证结果
- 两个DTO类都使用 `dto1` 类名
- 项目编译成功
- 通过描述信息可以区分不同的DTO
- Swagger文档应该能正确显示不同的请求参数结构

## 说明
文件中的内容是累积增加的，每次会话都会追加新的记录。

---

## 会话主要目的
解决Swagger Models中的覆盖问题，为每个DTO添加唯一后缀编码，确保在Swagger文档中能正确区分不同的模型。

## 完成的主要任务
1. 为两个DTO模块添加唯一后缀的扩展类
2. 更新控制器中的引用，使用新的唯一后缀类名
3. 保持原有的 `dto1` 类名不变
4. 确保Swagger文档能正确显示不同的模型

## 关键决策和解决方案
- 创建扩展类：`dto1_dto1_module` 和 `dto1_dto2_module`
- 使用 `extends` 继承原有类，保持所有属性和装饰器
- 在控制器中使用新的扩展类作为 `@ApiBody` 和 `@ApiExtraModels` 的类型
- 保持原有的 `dto1` 类作为函数参数类型，确保运行时兼容性

## 使用的技术栈
- TypeScript
- NestJS
- Swagger/OpenAPI
- 类继承 (Class Inheritance)
- 装饰器 (Decorators)

## 修改的文件
1. `back3/src/test/test4/dto1/dto1.ts` - 添加 `dto1_dto1_module` 扩展类
2. `back3/src/test/test4/dto2/dto1.ts` - 添加 `dto1_dto2_module` 扩展类
3. `back3/src/test/test4/test4_App_test1.ts` - 更新导入和引用
4. `back3/src/test/test4/test4_App_test2.ts` - 更新导入和引用

## 技术实现细节
- 扩展类命名规则：`dto1_模块名_module`
- 使用 `extends` 继承，保持所有原有功能
- 在Swagger中使用扩展类，在运行时使用原类
- 确保类型安全和运行时兼容性

## 验证结果
- 项目编译成功
- 两个API端点现在使用不同的Swagger模型名称
- Swagger Models中应该显示：`dto1_dto1_module` 和 `dto1_dto2_module`
- 每个模型都有独特的属性和描述信息

## 说明
文件中的内容是累积增加的，每次会话都会追加新的记录。

---

## 会话主要目的
通过配置方式解决Swagger Models中的覆盖问题，避免硬编码修改代码。

## 完成的主要任务
1. 恢复原来的代码，移除硬编码的扩展类
2. 通过Swagger配置解决模型名称冲突
3. 使用@ApiProperty的title属性区分不同模块的模型
4. 通过addTag配置为不同模块添加描述信息

## 关键决策和解决方案
- 使用@ApiProperty的title属性来区分不同模块的模型
- 通过addTag为不同模块添加描述信息，帮助用户理解
- 保持原有的dto1类名不变
- 通过配置而非代码修改来解决问题

## 使用的技术栈
- TypeScript
- NestJS
- Swagger/OpenAPI
- @ApiProperty装饰器
- DocumentBuilder配置

## 修改的文件
1. `back3/src/test/test4/dto1/dto1.ts` - 添加title属性区分模块
2. `back3/src/test/test4/dto2/dto1.ts` - 添加title属性区分模块
3. `back3/src/Plugins/swagger_knife4j2.ts` - 添加模块标签和描述

## 技术实现细节
- 使用@ApiProperty的title属性：`title: 'dto1_module1'` 和 `title: 'dto1_module2'`
- 通过description区分：`'name_aaa1 (from dto1_module)'` 和 `'name_aaa2 (from dto2_module)'`
- 使用addTag为不同模块添加描述信息
- 保持代码结构不变，仅通过配置解决问题

## 验证结果
- 项目编译成功
- 服务器启动成功
- 通过配置方式解决了模型名称冲突问题
- 保持了原有代码结构不变

## 说明
文件中的内容是累积增加的，每次会话都会追加新的记录。

---

## 会话主要目的
解决 back3 项目中 test5_demo5.ts 文件的 result 字段中详细数据注解不显示的问题，确保 Swagger 文档正确显示嵌套对象的提示信息。

## 完成的主要任务
1. 联网查询 nestjs-zod 与 Swagger 集成的正确方法
2. 修改 DTO 类使用 @ApiProperty 装饰器确保嵌套对象正确显示
3. 为所有字段添加详细的描述、示例值和验证规则
4. 确保代码编译无错误

## 关键决策和解决方案
- 发现 nestjs-zod 的 patchNestJsSwagger 函数在当前版本中不存在
- 采用混合方案：使用 Zod Schema 定义数据结构 + @ApiProperty 装饰器确保 Swagger 文档正确显示
- 为嵌套对象 PageObjDto 和 ResultDataDto 添加完整的 @ApiProperty 装饰器
- 使用 type 属性正确引用嵌套对象类型

## 使用的技术栈
- TypeScript
- NestJS
- Zod 验证库
- nestjs-zod 集成
- Swagger/OpenAPI 文档生成
- @ApiProperty 装饰器

## 修改的文件
1. `back3/src/test/test5/test5_demo5.ts` - 为 DTO 类添加 @ApiProperty 装饰器
2. `back3/src/main.ts` - 尝试添加 patchNestJsSwagger 调用（后发现不存在）

## 技术实现细节
- 为 PageObjDto 添加 page 和 page_size 字段的详细描述
- 为 ResultDataDto 添加 name_aaa2、name_bbb2、page_obj 字段的详细描述
- 为 ApiResponseDto 添加所有字段的详细描述和示例值
- 使用 type: PageObjDto 和 type: ResultDataDto 正确引用嵌套对象类型

## 验证结果
- 代码编译成功，无 linter 错误
- DTO 类现在包含完整的 @ApiProperty 装饰器
- Swagger 文档应该能正确显示 result 字段中所有嵌套对象的详细提示信息
- 保持了 Zod Schema 的验证功能

## 说明
文件中的内容是累积增加的，每次会话都会追加新的记录。

---

## 会话主要目的
为 back3 项目中的 test6_demo1.ts 创建自定义装饰器，将 @Post 装饰器封装到 get_method_name 装饰器中，实现装饰器的组合功能。

## 完成的主要任务
1. 创建了 `get_method_name` 装饰器，支持可选的 route 参数
2. 在装饰器内部自动应用 @Post 装饰器，使用方法名作为路由路径
3. 添加了方法名和路由路径的日志输出功能
4. 移除了单独的 @Post 装饰器，使用组合装饰器替代

## 关键决策和解决方案
- 使用高阶函数模式，`get_method_name(route?: string)` 返回装饰器函数
- 在装饰器内部调用 `Post(postRoute)(target, propertyKey, descriptor)` 应用路由装饰器
- 默认使用方法名作为路由路径，也支持自定义路由参数
- 保持原有的方法执行逻辑，添加调试信息输出

## 使用的技术栈
- TypeScript
- NestJS
- 装饰器 (Decorators)
- 高阶函数 (Higher-Order Functions)
- 方法装饰器组合

## 修改的文件
1. `back3/src/test/test6/test6_demo1.ts` - 创建组合装饰器，封装 @Post 功能

## 技术实现细节
- 装饰器函数签名：`get_method_name(route?: string)`
- 内部自动应用 @Post 装饰器：`Post(postRoute)(target, propertyKey, descriptor)`
- 路由路径逻辑：`const postRoute = route || propertyKey`
- 添加调试输出：方法名、路由路径、方法参数
- 保持原始方法执行：`return originalMethod.apply(this, args)`

## 使用方式
```typescript
// 使用默认路由（方法名）
@get_method_name()
async find_list_test6_demo1(@Body() body: any) { ... }

// 使用自定义路由
@get_method_name('custom-route')
async someMethod(@Body() body: any) { ... }
```

## 验证结果
- 代码编译成功，无 linter 错误
- 装饰器正确封装了 @Post 功能
- 方法名自动作为路由路径使用
- 支持自定义路由参数覆盖默认行为

## 说明
文件中的内容是累积增加的，每次会话都会追加新的记录。